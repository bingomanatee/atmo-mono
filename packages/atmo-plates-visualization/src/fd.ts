import {
  PlateSimulation,
  PlateSpectrumGenerator,
  type SimPlateIF,
} from '@wonderlandlabs/atmo-plates';
import { EARTH_RADIUS } from '@wonderlandlabs/atmo-utils'; // Use the correct Earth radius in meters
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { ForceVisualizer } from './ForceVisualizer';

// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111122);

// Camera setup
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  1,
  EARTH_RADIUS * 5,
);
camera.position.set(EARTH_RADIUS * 2, EARTH_RADIUS * 1.5, EARTH_RADIUS * 2);

// Renderer setup
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Enhanced Lighting
const ambientLight = new THREE.AmbientLight(0x404040, 0.6); // Increased ambient light
scene.add(ambientLight);

// Main directional light (sun)
const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0); // Increased intensity
directionalLight.position.set(
  EARTH_RADIUS * 2,
  EARTH_RADIUS * 2,
  EARTH_RADIUS * 2,
);
directionalLight.castShadow = true;

// Configure shadow properties
directionalLight.shadow.mapSize.width = 2048;
directionalLight.shadow.mapSize.height = 2048;
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = EARTH_RADIUS * 10;
directionalLight.shadow.camera.left = -EARTH_RADIUS * 3;
directionalLight.shadow.camera.right = EARTH_RADIUS * 3;
directionalLight.shadow.camera.top = EARTH_RADIUS * 3;
directionalLight.shadow.camera.bottom = -EARTH_RADIUS * 3;

scene.add(directionalLight);

// Add a secondary light for better illumination
const secondaryLight = new THREE.DirectionalLight(0xffffff, 1.0);
secondaryLight.position.set(-EARTH_RADIUS, EARTH_RADIUS, -EARTH_RADIUS);
scene.add(secondaryLight);

// Add planet sphere (Earth representation)
const planetGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 32, 32);
const planetMaterial = new THREE.MeshPhongMaterial({
  color: 0x2233ff,
  transparent: true,
  opacity: 0.3,
  wireframe: true,
});
const planet = new THREE.Mesh(planetGeometry, planetMaterial);
planet.receiveShadow = true; // Enable shadow receiving
scene.add(planet);

// Initialize PlateSimulation with smaller plates
const simulation = new PlateSimulation({
  planetRadius: EARTH_RADIUS,
  plateCount: 20, // Generate 20 smaller plates through normal generation
});
simulation.init();

// Check how many plates were generated by the normal process
const initialPlatesCount = simulation.simUniv.get('plates').count();

// --- Add Large Plates as well ---
// Generate large plates for better visualization
const largePlates = PlateSpectrumGenerator.generateLargePlates({
  planetRadius: EARTH_RADIUS,
  count: 12, // 12 large plates
  minRadius: Math.PI / 8, // Larger minimum size
  maxRadius: Math.PI / 4, // Larger maximum size
});

// Add large plates to the simulation (in addition to the smaller ones)
largePlates.forEach((plate, index) => {
  simulation.addPlate(plate);
});

// Initialize a map to hold ForceVisualizer instances for each plate
const plateVisualizers: Map<string, ForceVisualizer> = new Map();

// Get initial plates from the simulation and create visualizers (including large ones)
const initialPlates: SimPlateIF[] = Array.from(
  simulation.simUniv.get('plates').values(),
).map(([key, plate]) => plate);

initialPlates.forEach((plate, index) => {
  if (!plate.id || plate.radius === undefined || !plate.position) {
    return; // Skip this plate
  }

  const visualizer = new ForceVisualizer(scene, EARTH_RADIUS, plate);
  visualizer.visualize(); // Initialize the plate's visualization (cylinder)
  plateVisualizers.set(plate.id, visualizer);
});

// Animation loop with automatic force simulation
let lastForceUpdate = 0;
const FORCE_UPDATE_INTERVAL = 100; // Apply forces every 1 second for more visible movement

// Auto-run state and UI variables (declare early to avoid hoisting issues)
let autoRunEnabled = true;
let stepCount = 0;
const MAX_STEPS = 400; // Stop auto simulation after 400 steps when FD stabilizes

// Declare UI element variables that will be initialized later
let stepCounter: HTMLDivElement;
let forceInfo: HTMLDivElement;
let lastUpdateInfo: HTMLDivElement;

function animate() {
  const currentTime = Date.now();
  const timeSinceLastUpdate = currentTime - lastForceUpdate;

  // Automatically apply forces at regular intervals (if auto is enabled and under max steps)
  if (
    autoRunEnabled &&
    stepCount < MAX_STEPS &&
    timeSinceLastUpdate > FORCE_UPDATE_INTERVAL
  ) {
    performForceStep(true); // Don't await in animation loop to avoid blocking
    lastForceUpdate = currentTime;
  }

  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

// Handle window resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Add UI elements for simulation feedback
const uiContainer = document.createElement('div');
uiContainer.style.position = 'absolute';
uiContainer.style.top = '20px';
uiContainer.style.left = '20px';
uiContainer.style.zIndex = '1000';
uiContainer.style.fontFamily = 'Arial, sans-serif';
uiContainer.style.color = 'white';
uiContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
uiContainer.style.padding = '15px';
uiContainer.style.borderRadius = '10px';
uiContainer.style.minWidth = '250px';
document.body.appendChild(uiContainer);

// Step counter
stepCounter = document.createElement('div');
stepCounter.textContent = `Steps: ${stepCount}`;
stepCounter.style.marginBottom = '10px';
stepCounter.style.fontSize = '14px';
uiContainer.appendChild(stepCounter);

// Force info display
forceInfo = document.createElement('div');
forceInfo.textContent = 'Forces: Not calculated yet';
forceInfo.style.marginBottom = '10px';
forceInfo.style.fontSize = '12px';
uiContainer.appendChild(forceInfo);

// Last update time
lastUpdateInfo = document.createElement('div');
lastUpdateInfo.textContent = 'Last update: Never';
lastUpdateInfo.style.marginBottom = '15px';
lastUpdateInfo.style.fontSize = '12px';
lastUpdateInfo.style.color = '#ccc';
uiContainer.appendChild(lastUpdateInfo);

// Step button
const stepButton = document.createElement('button');
stepButton.textContent = 'Next Step';
stepButton.style.padding = '10px 20px';
stepButton.style.fontSize = '16px';
stepButton.style.backgroundColor = '#4CAF50';
stepButton.style.color = 'white';
stepButton.style.border = 'none';
stepButton.style.borderRadius = '5px';
stepButton.style.cursor = 'pointer';
stepButton.style.width = '100%';
stepButton.style.marginBottom = '10px';
uiContainer.appendChild(stepButton);

// Auto-run toggle
const autoToggle = document.createElement('button');
autoToggle.textContent = 'Auto: ON';
autoToggle.style.padding = '8px 16px';
autoToggle.style.fontSize = '14px';
autoToggle.style.backgroundColor = '#2196F3';
autoToggle.style.color = 'white';
autoToggle.style.border = 'none';
autoToggle.style.borderRadius = '5px';
autoToggle.style.cursor = 'pointer';
autoToggle.style.width = '100%';
uiContainer.appendChild(autoToggle);

// Function to perform a force simulation step and update UI
async function performForceStep(isAutomatic = false) {
  // Increment step counter
  stepCount++;
  stepCounter.textContent = `Steps: ${stepCount}/${MAX_STEPS}`;

  // Add visual feedback - flash the step counter
  const isComplete = stepCount >= MAX_STEPS;
  stepCounter.style.backgroundColor = isComplete ? '#FF6B6B' : '#4CAF50';
  setTimeout(() => {
    stepCounter.style.backgroundColor = 'transparent';
  }, 200);

  // Auto-disable when reaching max steps
  if (isComplete && autoRunEnabled) {
    autoRunEnabled = false;
    autoToggle.textContent = 'Auto: OFF (Complete)';
    autoToggle.style.backgroundColor = '#666';
  }

  // Run one simulation step and get the forces
  const forces = await simulation.applyForceLayout();

  // Calculate force statistics
  let totalMagnitude = 0;
  let maxMagnitude = 0;

  forces.forEach((force, plateId) => {
    const magnitude = force.length();
    totalMagnitude += magnitude;
    maxMagnitude = Math.max(maxMagnitude, magnitude);
  });

  // Update force info display
  const avgMagnitude = forces.size > 0 ? totalMagnitude / forces.size : 0;
  forceInfo.textContent = `Forces: ${forces.size} | Avg: ${Math.round(avgMagnitude)} | Max: ${Math.round(maxMagnitude)}`;

  // Update last update time
  const now = new Date();
  lastUpdateInfo.textContent = `Last update: ${now.toLocaleTimeString()}`;

  // Get the updated plates using find generator filtered by simulation ID
  const updatedPlates: SimPlateIF[] = [];

  for (const [id, plate] of simulation.simUniv
    .get('plates')
    .find('simId', simulation.simulationId)) {
    updatedPlates.push(plate);
  }

  // Update each plate visualizer with the new plate data and forces
  for (const [id, updatedPlate] of simulation.simUniv
    .get('plates')
    .find('simId', simulation.simulationId)) {
    const visualizer = plateVisualizers.get(updatedPlate.id);
    if (visualizer) {
      visualizer.update(updatedPlates, forces);
    }
  }
}

// Auto-toggle functionality
autoToggle.addEventListener('click', () => {
  autoRunEnabled = !autoRunEnabled;
  autoToggle.textContent = `Auto: ${autoRunEnabled ? 'ON' : 'OFF'}`;
  autoToggle.style.backgroundColor = autoRunEnabled ? '#2196F3' : '#666';
});

// Event listener for manual step button
stepButton.addEventListener('click', async () => {
  await performForceStep(false);
});

// Start the animation loop after all UI elements are created
animate();
