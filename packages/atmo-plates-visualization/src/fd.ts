import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { PlateSimulation, type SimPlateIF } from '@wonderlandlabs/atmo-plates';
import { ForceVisualizer } from './ForceVisualizer';
import { PlateSpectrumGenerator } from '@wonderlandlabs/atmo-plates';

// Earth radius in kilometers (not meters like the atmo-utils constant)
const EARTH_RADIUS = 6371; // km

// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111122);

// Camera setup
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  1,
  EARTH_RADIUS * 5,
);
camera.position.set(EARTH_RADIUS * 2, EARTH_RADIUS * 1.5, EARTH_RADIUS * 2);

// Renderer setup
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Enhanced Lighting
const ambientLight = new THREE.AmbientLight(0x404040, 0.6); // Increased ambient light
scene.add(ambientLight);

// Main directional light (sun)
const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0); // Increased intensity
directionalLight.position.set(
  EARTH_RADIUS * 2,
  EARTH_RADIUS * 2,
  EARTH_RADIUS * 2,
);
directionalLight.castShadow = true;

// Configure shadow properties
directionalLight.shadow.mapSize.width = 2048;
directionalLight.shadow.mapSize.height = 2048;
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = EARTH_RADIUS * 10;
directionalLight.shadow.camera.left = -EARTH_RADIUS * 3;
directionalLight.shadow.camera.right = EARTH_RADIUS * 3;
directionalLight.shadow.camera.top = EARTH_RADIUS * 3;
directionalLight.shadow.camera.bottom = -EARTH_RADIUS * 3;

scene.add(directionalLight);

// Add a secondary light for better illumination
const secondaryLight = new THREE.DirectionalLight(0xffffff, 1.0);
secondaryLight.position.set(-EARTH_RADIUS, EARTH_RADIUS, -EARTH_RADIUS);
scene.add(secondaryLight);

// Add planet sphere (Earth representation)
const planetGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 32, 32);
const planetMaterial = new THREE.MeshPhongMaterial({
  color: 0x2233ff,
  transparent: true,
  opacity: 0.3,
  wireframe: true,
});
const planet = new THREE.Mesh(planetGeometry, planetMaterial);
planet.receiveShadow = true; // Enable shadow receiving
scene.add(planet);

// Initialize PlateSimulation with smaller plates
const simulation = new PlateSimulation({
  planetRadius: EARTH_RADIUS,
  plateCount: 20, // Generate 20 smaller plates through normal generation
});
simulation.init();

// Check how many plates were generated by the normal process
const initialPlatesCount = simulation.simUniv.get('plates').count();
console.log(
  `Generated ${initialPlatesCount} smaller plates through normal generation`,
);

// --- Add Large Plates as well ---
// Generate large plates for better visualization
const largePlates = PlateSpectrumGenerator.generateLargePlates({
  planetRadius: EARTH_RADIUS,
  count: 12, // 12 large plates
  minRadius: Math.PI / 8, // Larger minimum size
  maxRadius: Math.PI / 4, // Larger maximum size
});

// Add large plates to the simulation (in addition to the smaller ones)
console.log(`Generated ${largePlates.length} large plates`);
largePlates.forEach((plate, index) => {
  console.log(`Adding large plate ${index + 1}:`, {
    radius: plate.radius,
    density: plate.density,
    thickness: plate.thickness,
  });
  simulation.addPlate(plate);
});

// Initialize a map to hold ForceVisualizer instances for each plate
const plateVisualizers: Map<string, ForceVisualizer> = new Map();

// Get initial plates from the simulation and create visualizers (including large ones)
const initialPlates: SimPlateIF[] = Array.from(
  simulation.simUniv.get('plates').values(),
).map(([key, plate]) => plate);

console.log(
  `Found ${initialPlates.length} total plates in simulation for visualization (${initialPlatesCount} smaller + ${largePlates.length} large)`,
);

initialPlates.forEach((plate, index) => {
  console.log(`Visualizing plate ${index + 1}:`, {
    id: plate.id,
    radius: plate.radius,
    position: plate.position,
    density: plate.density,
  });

  if (!plate.id || plate.radius === undefined || !plate.position) {
    console.warn(`Skipping plate ${index + 1} due to missing properties`);
    return; // Skip this plate
  }

  const visualizer = new ForceVisualizer(scene, EARTH_RADIUS, plate);
  visualizer.visualize(); // Initialize the plate's visualization (cylinder)
  plateVisualizers.set(plate.id, visualizer);
});

console.log(`Created ${plateVisualizers.size} plate visualizers`);

// Animation loop with automatic force simulation
let lastForceUpdate = 0;
const FORCE_UPDATE_INTERVAL = 2000; // Apply forces every 2 seconds

function animate() {
  requestAnimationFrame(animate);

  const currentTime = Date.now();

  // Automatically apply forces at regular intervals
  if (currentTime - lastForceUpdate > FORCE_UPDATE_INTERVAL) {
    // Run one simulation step and get the forces
    const forces = simulation.applyForceLayout();

    // Get the updated plates
    const updatedPlates: SimPlateIF[] = Array.from(
      simulation.simUniv.get('plates').values(),
    ).map(([key, plate]) => plate);

    // Update each plate visualizer with the new plate data and forces
    updatedPlates.forEach((updatedPlate) => {
      const visualizer = plateVisualizers.get(updatedPlate.id);
      if (visualizer) {
        visualizer.update(updatedPlates, forces);
      }
    });

    lastForceUpdate = currentTime;
  }

  controls.update();
  renderer.render(scene, camera);
}

animate();

// Handle window resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Add a button to trigger simulation steps
const stepButton = document.createElement('button');
stepButton.textContent = 'Next Step';
stepButton.style.position = 'absolute';
stepButton.style.top = '20px';
stepButton.style.left = '20px';
stepButton.style.zIndex = '1000';
stepButton.style.padding = '10px 20px';
stepButton.style.fontSize = '16px';
stepButton.style.backgroundColor = '#4CAF50';
stepButton.style.color = 'white';
stepButton.style.border = 'none';
stepButton.style.borderRadius = '5px';
stepButton.style.cursor = 'pointer';
stepButton.style.fontFamily = 'Arial, sans-serif';
document.body.appendChild(stepButton);

// Event listener for the button
stepButton.addEventListener('click', () => {
  // Run one simulation step and get the forces
  const forces = simulation.applyForceLayout();

  // Get the updated plates
  const updatedPlates: SimPlateIF[] = Array.from(
    simulation.simUniv.get('plates').values(),
  ).map(([key, plate]) => plate);

  // Update each plate visualizer with the new plate data and forces
  updatedPlates.forEach((updatedPlate) => {
    const visualizer = plateVisualizers.get(updatedPlate.id);
    if (visualizer) {
      // We need to pass the entire updatedPlates array and the forces map
      visualizer.update(updatedPlates, forces);
    }
  });
});
